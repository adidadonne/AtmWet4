#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <signal.h>
#include <syscall.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/reg.h>
#include <sys/user.h>
#include <unistd.h>
#include <errno.h>
#include <stdbool.h>
#include <string.h>

#include "elf64.h"

#define ELF_NOT_EXECUTABLE -3
#define SYMBOL_NAME_ONLY_LOCAL -2
#define SYMBOL_NOT_EXIST -1
#define ET_EXEC 2
#define SHT_SYMTAB 2

long find_symbol(char* symbol_name, char* exe_file_name, unsigned int* local_count);
pid_t run_target(const char* programname);
void run_Debugger();

long find_symbol(char* symbol_name, char* exe_file_name, unsigned int* local_count)
{
    /// checking if file is executable
    Elf64_Ehdr header;
    FILE * elf_file=fopen(exe_file_name,"rb");
    if(elf_file==NULL) exit(1);
    fread(&header, sizeof(header),1 , elf_file);
    if(header.e_type != ET_EXEC)
        {
            fclose(elf_file);
            return ELF_NOT_EXECUTABLE;
        }
    /// creating section header array
    fseek(elf_file, header.e_shoff, SEEK_SET);
    Elf64_Shdr *section_header = (Elf64_Shdr *) malloc(sizeof(Elf64_Shdr) * header.e_shnum);
    if (section_header == NULL)
    {
        fclose(elf_file);
        exit(1);
    }
    /// updating / filling the section_header array with data
    for (int i = 0; i <header.e_shnum; i++)
    {
       fread(&section_header[i], sizeof(Elf64_Shdr), 1, elf_file);
    }

    ///looking for
    ///
    /// mbol section
    Elf64_Off strtableOff = 0;
    Elf64_Xword strtableSize = 0;

    Elf64_Shdr symSection;
    int local=0;
    bool global= false;
    for (int i=0; i<header.e_shnum;i++)
    {
        if ((section_header[i].sh_type == 3) && (i != header.e_shstrndx))
        {
            strtableOff = section_header[i].sh_offset;
            strtableSize = section_header[i].sh_size;
            for (int i = 0; i < header.e_shnum; i++)
            {
                if (section_header[i].sh_type == 2) {
                    symSection = section_header[i];
                }
            }

            int numEnt = symSection.sh_size / symSection.sh_entsize;
            ///creating symtable array
            Elf64_Sym *symtable = (Elf64_Sym *) malloc((numEnt) * sizeof(Elf64_Sym));
            if (symtable == NULL) {
                fclose(elf_file);
                free(section_header);
                exit(1);
            }
            /// updating / filling the sym section array with data
            fseek(elf_file, symSection.sh_offset, SEEK_SET);
            for (int i = 0; i < numEnt; ++i) {
                fread(&symtable[i], sizeof(Elf64_Sym), 1, elf_file);
            }
            ///creating temp str
            char *str = (char *) malloc(strtableSize * sizeof(char));
            char c_temp;
            if (str == NULL) {
                fclose(elf_file);
                free(section_header);
                free(symtable);
                exit(1);
            }
            for (int i = 0; i < numEnt; ++i) {
                if (symtable[i].st_name) {
                    fseek(elf_file, strtableOff + symtable[i].st_name, SEEK_SET);
                    c_temp = getc(elf_file);
                    int j = 0;
                    for (; c_temp; j++) {
                        str[j] = c_temp;
                        c_temp = getc(elf_file);
                    }
                    str[j] = c_temp;
                }
                if (strcmp(str, symbol_name) == 0) {
                    if (ELF64_ST_BIND(symtable[i].st_info) == 1) {
                        global = true;
                        *local_count = symtable[i].st_value;
                        break;
                    } else if (ELF64_ST_BIND(symtable[i].st_info) == 0) {
                        local++;
                    }
                }
            }
            free(str);
            free(symtable);
        }
    }
    if(global==false && local==0)
    {
        fclose(elf_file);
        free(section_header);
        return SYMBOL_NOT_EXIST;
    }
    if(global)
    {
        fclose(elf_file);
        free(section_header);
        return *local_count;
    }
    if(global==false && local!=0)
    {
        fclose(elf_file);
        free(section_header);
        *local_count=local;
        return SYMBOL_NAME_ONLY_LOCAL;
    }
}
pid_t run_target(const char* programname) {
    pid_t pid;

    pid = fork();
    if (pid > 0){
        return pid;

    }else if (pid == 0) {
        /* Allow tracing of this process */
        if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) < 0) {
            perror("ptrace");
            exit(1);
        }
        /* Replace this process's image with the given program */
        execl(programname, programname, NULL);

    } else {
        // fork error
        perror("fork");
        exit(1);
    }
}

char* decToHex(unsigned long long c){
    char *tmp = (char *) malloc(sizeof(char)*18);
    int i = 0;
    int helper = 0;
    while (c != 0)
    {
        helper = 0;
        helper = c % 16;
        if(helper < 10)
        {
            tmp[i] = helper + '0';
            i++;
        }
        else
        {
            tmp[i] = helper + 'a' - 10;
            i++;
        }
        c = c / 16;
    }
    while(i < 18)
    {
        tmp[i] = 0;
        i++;
    }
    return tmp;
}

void reverseString(char* str)
{
    int count = 0;
    while (str[count] != '\0')
    {
        count++;
    }
    char *tmp = (char *) malloc(count* sizeof(char));
    int end = count - 1;
    int j = 0;
    for(int i=end; i>=0; i--)
    {
        tmp[j] = str[i];
        j++;
    }
    strcpy(str, tmp);
    free(tmp);
}
void run_Debugger(pid_t child_pid, const unsigned long long addr)
{
    int wait_status;
    struct user_regs_struct regs;
    wait(&wait_status);
    /*update the breakpoints we put one on the beginning of the function address, when we enter the func we remove
      the that breakpoint and but one on the return address of the function' to know that the function is done*/

    unsigned long long rbp_check = 0;
    while(!WIFEXITED(wait_status)){
        unsigned long long data_func = ptrace(PTRACE_PEEKTEXT, child_pid, (void*)addr, NULL);//ORIGINAL DATA
        unsigned long long trap = (data_func & 0xFFFFFFFFFFFFFF00) | 0xCC;
        ptrace(PTRACE_POKETEXT,child_pid, (void*)addr, (void*)trap);
        ptrace(PTRACE_CONT, child_pid, 0, 0);

        wait(&wait_status);

        ptrace(PTRACE_GETREGS, child_pid, 0, &regs);
        ptrace(PTRACE_POKETEXT,child_pid,(void*)addr,(void*)data_func);
        if((regs.rip-1) != addr){
            continue;
        }


        ptrace(PTRACE_GETREGS, child_pid, 0, &regs);
        /////
        if(rbp_check == 0){
            rbp_check = regs.rbp;
        }
        ////
        regs.rip-=1;
        ptrace(PTRACE_SETREGS, child_pid, 0, &regs);

        unsigned long long func_aux = ptrace(PTRACE_PEEKTEXT, child_pid, (void *) regs.rsp, NULL);

        unsigned long long data_func_2 = ptrace(PTRACE_PEEKTEXT, child_pid, (void *) func_aux, NULL);
        unsigned long long trap_2 = (data_func_2 & 0xFFFFFFFFFFFFFF00) | 0xCC;

        ptrace(PTRACE_POKETEXT, child_pid, (void *) func_aux, (void *) trap_2);

        /*we run over all the syscalls and check the return value if it is negative we do what we are supposed
          to do, otherwise we continue to the next syscall*/
        while(1){
            ptrace(PTRACE_SYSCALL, child_pid, NULL, NULL);
            wait(&wait_status);
            ptrace(PTRACE_GETREGS, child_pid, 0, &regs);

            /*if we are at the return address we remove the breakpoint and return the opcode as it was before adding the breakpoint*/
            if ((regs.rip-1) == func_aux){
                ptrace(PTRACE_GETREGS, child_pid, 0, &regs);
                ptrace(PTRACE_POKETEXT, child_pid, (void *) func_aux, (void *) data_func_2);
                regs.rip-=1;
                ptrace(PTRACE_SETREGS, child_pid, 0, &regs);

                if(regs.rbp == rbp_check){
                    rbp_check = 0;
                    break;
                }

                ptrace(PTRACE_SINGLESTEP,child_pid,NULL,NULL);
                wait(&wait_status);
                ptrace(PTRACE_POKETEXT, child_pid, (void *) func_aux, (void *) trap_2);
            }
            ptrace(PTRACE_SYSCALL, child_pid, NULL, NULL);
            wait(&wait_status);
            ptrace(PTRACE_GETREGS, child_pid, 0, &regs);

            if((long long int)regs.rax < 0) {
                char *addr_syscall = decToHex((regs.rip-2));
                reverseString(addr_syscall);
                printf("PRF:: the syscall in 0x%s returned with %lld\n", addr_syscall, regs.rax);
            }
            continue;
        }
    }
}

int main(int argc, char** argv) {
   // long find_symbol(char* symbol_name, char* exe_file_name, unsigned int* local_count)
     unsigned int* local_count;
    int res = find_symbol(argv[1],argv[2],local_count);
    if (res == ELF_NOT_EXECUTABLE )
    {
        printf( "PRF:: %s not an executable!\n", argv[1]);
    }
    else if (res == SYMBOL_NOT_EXIST ){

        printf( "PRF:: %s not found!\n", argv[1]);
    }
    else if (res == SYMBOL_NAME_ONLY_LOCAL )
    {
        printf( "PRF:: %s is a local symbol %d times!\n", argv[1], *local_count);
    }
    unsigned long address= *local_count;
    if(res==*local_count)
    {
        pid_t child_pid;
        child_pid = run_target(argv[2]);
        run_Debugger(child_pid, address);
    }

    return 0;
}

